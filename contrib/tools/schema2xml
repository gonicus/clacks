#!/usr/bin/env python
import os
import copy
import ldap.schema
import logging
from argparse import ArgumentParser
from lxml import etree
from lxml.builder import ElementMaker

VERSION = "1.0"
TYPE_MAP = {
    "1.3.6.1.4.1.1466.115.121.1.6": dict(name="Binary"),
    "1.3.6.1.4.1.1466.115.121.1.7": dict(name="Boolean"),
    "1.3.6.1.4.1.1466.115.121.1.12": dict(name="UnicodeString"),
    "1.3.6.1.4.1.1466.115.121.1.15": dict(name="UnicodeString"),
    "1.3.6.1.4.1.1466.115.121.1.24": dict(name="Timestamp"),
    "1.3.6.1.4.1.1466.115.121.1.26": dict(name="String"),
    "1.3.6.1.4.1.1466.115.121.1.27": dict(name="Integer"),
    "1.3.6.1.4.1.1466.115.121.1.28": dict(name="Binary"),
    "1.3.6.1.4.1.1466.115.121.1.44": dict(name="UnicodeString"),
    "1.3.6.1.4.1.1466.115.121.1.53": dict(name="Timestamp"),

    "1.3.6.1.4.1.1466.115.121.1.41": dict(name="UnicodeString", comment="---> Postal Address"),
    "1.3.6.1.4.1.1466.115.121.1.36": dict(name="UnicodeString", comment="Numeric String"),
    "1.3.6.1.4.1.1466.115.121.1.51": dict(name="UnicodeString", comment="A printable string optionaly one or more parameters separed by a $ sign"),
    "1.3.6.1.4.1.1466.115.121.1.52": dict(name="UnicodeString", comment="actual-number $ country $ answerback"),
    "1.3.6.1.4.1.1466.115.121.1.14": dict(name="String", comment='Delivery Method of an object. One of the following. "any" "mhs" "physical" "telex" "teletex" "g3fax" "g4fax" "ia5" "videotex" "telephone"'),
    "1.3.6.1.4.1.1466.115.121.1.22": dict(name="String", comment='''      fax-number    = printablestring [ "$" faxparameters ]

      faxparameters = faxparm / ( faxparm "$" faxparameters )

      faxparm = "twoDimensional" / "fineResolution" /
                "unlimitedLength" /
                "b4Length" / "a3Width" / "b4Width" / "uncompressed"'''),
    "1.3.6.1.4.1.1466.115.121.1.50": dict(name="String", regex=r"\+[0-9]{2}\s*[0-9\s]+"),
}


log = logging.getLogger("schema2xml")
logging.basicConfig(level=logging.INFO, format='%(levelname)s: %(message)s')


def list_classes(uri):
    subschemasubentry_dn, schema = ldap.schema.urlfetch(uri)
    schema_reverse = ldap.schema.SubSchema(schema.ldap_entry())
    
    ocs = ldap.schema.SCHEMA_CLASS_MAPPING['objectclasses']
    for element_id in schema.listall(ocs):
        obj = schema.get_obj(ocs, element_id)
        print("%s - %s" % (obj.names[0], obj.desc or "no description"))


def dump_class(uri, oc, outfile=None, extend=None, rdn=None):
    subschemasubentry_dn, schema = ldap.schema.urlfetch(uri)
    schema_reverse = ldap.schema.SubSchema(schema.ldap_entry())
    
    oco = schema.get_obj(ldap.schema.ObjectClass, oc)
    if oco is None:
        log.error("unknown objectclass '%s' - please use the --list option to see what's there" % oc)
        exit(1)

    outfile = outfile or "%s.xml" % oc

    # Complete attributes in case of inheritance
    if oco.kind == 0:
        r = resolve_inherited_attrs(schema, oco.sup[0])
        oco.must = list(set(list(oco.must) + r['must']))
        oco.may = list(set(list(oco.may) + r['must']))

    # Build resulting XML dump
    e = ElementMaker(namespace="http://www.gonicus.de/Objects", nsmap={None: "http://www.gonicus.de/Objects"})
    more = []
    if oco.desc:
        more.append(e.Description(oco.desc))
    more.append(e.Backend("LDAP"))
    if oco.kind == 0:
        if not rdn:
            log.error("no RDN provided - please use --rdn <value> to specify one")
            exit(1)
        more.append(e.BackendParameters(e.Backend("LDAP", objectClasses=oc, RDN=rdn)))

    if oco.kind != 0:
        more.append(e.BaseObject("false"))

    # Build attribute set
    attrs = []
    for mua in oco.must:
        attr = resolve_attribute(schema, mua)
        attrs.append(
           e.Attribute(
               e.Name(attr['name']),
               e.Description(attr['desc']),
               e.Type(attr['type']),
               e.Multivalue("true" if attr['multivalue'] else "false"),
               e.Mandatory("true")))
    for mua in oco.may:
        attr = resolve_attribute(schema, mua)
        attrs.append(
           e.Attribute(
               e.Name(attr['name']),
               e.Description(attr['desc']),
               e.Type(attr['type']),
               e.Multivalue("true" if attr['multivalue'] else "false"),
               e.Mandatory("false")))

    more.append(e.Attributes(*attrs))

    # Maintain extension
    if extend:
        more.append(e.Extends(e.Value(extend)))

    print '<?xml version="1.0" encoding="UTF-8"?>'
    data = e.Objects(e.Object(e.Name(oc), e.DisplayName(oc)), *more)
    print etree.tostring(data, pretty_print=True)


def resolve_type(atype):
    if not atype in TYPE_MAP:
        log.warning("unknown mapping for %s - fallback to UnicodeString" % atype)
        return "UnicodeString"

    return TYPE_MAP[atype]['name']


def resolve_inherited_attrs(schema, oc):
    res = {'must': [], 'may': []}
    if oc == 'top':
        return res

    noc = schema.get_obj(ldap.schema.ObjectClass, oc)
    if noc.kind == 0:
       r = resolve_inherited_attrs(schema, noc.sup[0])
       res['must'] += r['must']
       res['may'] += r['may']

    res['must'] += list(noc.must)
    res['may'] += list(noc.may)

    return res


def _resolve_attribute(schema, attr, blank=None):
    if not blank:
        blank = ldap.schema.AttributeType()
        blank.syntax_len = None

    if attr.sup:
        sup = schema.get_obj(ldap.schema.AttributeType, attr.sup[0])
        if sup.syntax:
            blank.syntax = sup.syntax
        if sup.syntax_len:
            blank.syntax_len = sup.syntax_len
        if sup.equality:
            blank.equality = sup.equality
        if sup.substr:
            blank.substr = sup.substr
        return _resolve_attribute(schema, sup, blank)

    return blank


def resolve_attribute(schema, attr):
    blank = {}
    attr = schema.get_obj(ldap.schema.AttributeType, attr)

    if attr.sup:
       inh = _resolve_attribute(schema, attr)
    else:
       inh = None

    blank['name'] = attr.names[0]
    blank['desc'] = attr.desc or "no description"
    blank['sup'] = inh != None
    blank['type'] = resolve_type(attr.syntax or inh.syntax)
    blank['maxlen'] = attr.syntax_len or (inh and inh.syntax_len) or None
    blank['multivalue'] = not attr.single_value
    blank['writable'] = not attr.no_user_mod
    blank['index'] = True if attr.equality or attr.substr or (inh and (inh.equality or inh.substr)) else False

    return blank


def main():
    parser = ArgumentParser(usage="%(prog)s - clacks schema conversion tool")
    parser.add_argument("--version", action='version', version=VERSION)

    parser.add_argument("--uri", dest="uri", default="ldapi:///",
                      help="URI of LDAP server which contains the required schema",
                      metavar="URI")
    parser.add_argument("-l", "--list", dest="list", action="store_true",
                      help="show list of available objectclasses")
    parser.add_argument("-o", "--output-file", dest="target",
                      help="write output to FILE, defaults to objectclass name.xml",
                      metavar="FILE")
    parser.add_argument("--rdn", dest="rdn", default="None",
                      help="RDN to use for primary objects",
                      metavar="RDN")
    parser.add_argument("--extend", dest="extend", default="None",
                      help="object NAME you want to extend",
                      metavar="NAME")
    #TODO: container

    parser.add_argument('oc', metavar='str', type=str, help='class to be converted', nargs='?')
    options = parser.parse_args()

    if options.list:
        list_classes(options.uri)
        exit(0)

    if not options.oc:
        log.error("please provide an objectclass to be converted")
        exit(1)

    dump_class(options.uri, options.oc, options.target, options.extend, options.rdn)

if __name__ == "__main__":
    main()
