#!/usr/bin/env python
# -*- coding: utf-8 -*-
import os
import sys
import grp
import pynotify
import gobject
import dbus
import dbus.mainloop.glib
import sched
import time
from threading import Timer
from optparse import OptionParser, OptionValueError
from pwd import getpwnam

# Define return codes
RETURN_ABORTED = 0b10000000
RETURN_TIMEDOUT = 0b1000000
RETURN_CLOSED_WITH_ACTION = 0b100000
RETURN_CLOSED = 0b10000
# 000 to 111 are selected action types.


class Notify(object):
    __actions = None
    __loop = None

    def __init__(self):
        pynotify.init('gosa-ng')

    def __callback(self, notification=None, action=None, data=None):
        """
        __callback acts on notification actions, if actions were defined.
        """

        # Get the selected action id, the first is 0 so we just add +1 to it,
        # to get a more useable return code.
        self.__res = (self.__actions.index(data) + 1) | RETURN_CLOSED_WITH_ACTION
        self.__notify.close()
        self.__loop.quit()

    def notification_closed(self, *args, **kwargs):
        """
        notification_closed is called whenever a notification is closed
        If no action was selected from the given ones, then show the
        notification again.
        """
        # Is there a valid result selected? If not, then show the dialog again.
        if self.__actions and self.__res == -1:
            try:
                time.sleep(self.__recurrenceTime)
                self.__notify.show()
            except KeyboardInterrupt:
                self.__res = RETURN_ABORTED
                self.__loop.quit()
        else:
            self.__loop.quit()

    def send(self, title, message, icon="dialog-information",
        urgency=pynotify.URGENCY_NORMAL,
        timeout=pynotify.EXPIRES_DEFAULT,
        recurrence=60, **kwargs):
        """
        send    initiates the notification with the given option details.
        If actions were specified then it hooks in the MainLoop to keep
        the programm running till an action was selected or the programm
        was interrupted.
        """

        # Initially start with result id 0 for non-action notificatiuons
        #  and with 255 for action notifications.
        self.__res = -1

        # Build dialog
        self.__notify = pynotify.Notification(title, message, icon)

        # Set up notification details like actions
        self.__notify.set_urgency(urgency)
        if 'actions' in kwargs:
            self.__notify.set_timeout(pynotify.EXPIRES_NEVER)
            self.__recurrenceTime = recurrence
            self.__actions = kwargs['actions']
            for action in kwargs['actions']:
                self.__notify.add_action(action, action, self.__callback, action)
        else:
            self.__notify.set_timeout(timeout)

        # Display the notification
        self.__notify.show()

        # Register provided actions and then hook in the main loop
        if not self.__actions:
            self.__res = RETURN_CLOSED
        else:

            # Register callback for 'NotificationClosed' event on the dbus.
            dbus.mainloop.glib.DBusGMainLoop(set_as_default=True)
            bus = dbus.SessionBus()
            bus.add_signal_receiver(self.notification_closed,
                dbus_interface="org.freedesktop.Notifications", signal_name="NotificationClosed")

            # Hook in the main loop, to keep the programm running till an actoins
            # was selected or the application was closed.
            self.__loop = gobject.MainLoop()
            try:
                self.__loop.run()
            except KeyboardInterrupt:
                try:
                    self.__notify.close()
                except gobject.GError:
                    pass
                self.__res = RETURN_ABORTED

        return self.__res


def checkUrgency(option, opt, value, parser):
    """
    checkUrgency    checks whether the given value for the urgency option
    is valid or not and then updates the cli-option-parser
    It defaults to pynotify.URGENCY_NORMAL.
    """

    # Create a dictionary for all valid values.
    attrMap = {}
    attrMap[None] = pynotify.URGENCY_NORMAL
    attrMap['critical'] = pynotify.URGENCY_CRITICAL
    attrMap['normal'] = pynotify.URGENCY_NORMAL
    attrMap['low'] = pynotify.URGENCY_LOW

    # If a invalid value was specified, then tell the user and default to normal.
    if value not in attrMap:
        raise OptionValueError("Invalid urgency level specified. (critical, normal, low)")
        value = None

    # Update the cli-option-parser now.
    parser.values.urgency = value

if __name__ == '__main__':
    n = Notify()

    # Define cli-script parameters
    parser = OptionParser(description="Sends a notification dialog "
        "to a user on the local machine.",
        prog="notify", usage="%prog <message> <title> [options] ")

    parser.add_option("-l", "--urgency", type="string", help="Urgency level",
        callback=checkUrgency, action="callback", default=pynotify.URGENCY_NORMAL)
    parser.add_option("-i", "--icon", dest="icon",
        help="An icon file to use in the notifcation", metavar="FILE")
    parser.add_option("-t", "--timeout", dest="timeout",
        help="Milliseconds the notification is displayed")
    parser.add_option("-u", "--user", dest="user", help="The target user")
    parser.add_option("-q", "--quiet", action="store_false", dest="verbose",
        default=True, help="don't print status messages to stdout")
    parser.add_option("-a", "--actions", dest="actions",
        help="A list of actions the notification is displayed. E.g. -a 'yes,no'")
    parser.add_option("-r", "--recurrence-time", dest="recurrence", type="float",
        help="Recurrence time of unanswered actions notifications.", default=60)

    # Check if at least 'message' and 'title' are given.
    (options, args) = parser.parse_args()
    if len(args) != 2:
        parser.print_help()
    else:

        # Prepare actions
        actions = []
        if options.actions:
            actions = options.actions.split(',')

        # Check if actions and timeout are given, timeout will be ignored in this case.
        if options.actions and options.timeout and options.verbose:
            print "The options 'timeout' and 'actions' cannot be combined, timeout will be ingored!"

        # Ensure that the timeout is valid
        if options.timeout:
            options.timeout = int(options.timeout)
        else:
            options.timeout = pynotify.EXPIRES_DEFAULT

        # We've to run as another user
        if options.user:

            # Detecting groups of user hickert
            gids = []
            for a in grp.getgrall():
                if options.user in a.gr_mem:
                    gids.append(a.gr_gid)

            # Now Switch to the selected user, primary group und uid
            #  for the current os environment
            info = getpwnam(options.user)

            # Set the users groups
            os.setgroups(gids)
            os.setgid(info[3])
            os.setuid(info[2])

            # Remove --user and -u parameter from the
            #  parameter list to avoid an endless recursion
            args = sys.argv
            if "-u" in args:
                args.remove("-u")
            if "--user" in args:
                args.remove("--user")
            args.remove(options.user)

            # Execute the notification script as the given user.
            sys.exit(os.execv(sys.argv[0], args))

        else:

            # Try to send the notification now.
            sys.exit(n.send(args[0], args[1], actions=actions, icon=options.icon,
                urgency=options.urgency, timeout=options.timeout, recurrence=options.recurrence))


###############################################
# Usecases:
#
# 1) Simple Nachricht
#    Timeout, Titel, Nachricht (HTML), Icon, Urgency (low, normal, critical)
#
#    Timeout:
#    EXPIRES_DEFAULT = -1
#    EXPIRES_NEVER = 0
#
#    Urgency:
#    URGENCY_CRITICAL
#    URGENCY_LOW
#    URGENCY_NORMAL
#
#    Icon (z.B.):
#    dialog-information
#    dialog-warning
#    dialog-error
#    dialog-question
#
# 2) Nachricht mit Callbacks
#    Timeout (mandatory), Titel, Nachricht (HTML), Icon, Urgency (low, normal, critical)
#    "Button 1", "Button 2", ...
#
#    -> wartet auf bestÃ¤tigung, max. timeout -> -1
