\chapter{GOsa Architektur}

\section{Kommunikation von Komponenten}

Alle GOsa-Server sind über einen Nachrichtenbus (AMQP) miteinander verbunden. Kommt ein Server
hinzu, oder verlässt ein Server den Verbund, wird ein Event ausgelöst.

Beim Hinzukommen wird gibt ein Server seine Capabilities bekannt (=die Funktionen die er
zur Verfügung stellt). Jeder weitere Server empfängt diese Meldung und aktualisiert seinen
Wissensstand zu der neu hinzugekommenen Instanz.

Wird von einem Client eine bestimmte Funktionalität angefordert, so kann über die Capabilites
herausgefunden werden welche(r) Server für diese Aufgabe in Betracht kommt.

Capabilities haben neben einem Funktionsnamen noch weitere Eigenschaften, mit denen z.B. eine
Verteilung der Aufrufe auf unterschiedliche Systeme erreicht werden kann. Die Repository-
Funktion \glqq listPackages\grqq\ kann unter Umständen die gewünschte Information nicht in jedem Fall
liefern, da der beantwortende Server nur über einen Teil des Repositories verfügt.

Beim Verlassen des Verbundes wird die Capability-Liste entsprechend aktualisiert.

\subsection{Standard Queues}

Für jede von GOsa verwaltete Domain wird eine virtuelle AMQP-Domain bereitgestellt. Dies stellt
sicher, dass zwischen den Domains keinerlei Informationen ausgetauscht werden können.

Die virtuelle AMQP-Domain stellt das Nachrichten-Backbone von GOsa dar und definiert
eine Hand voll Standard-Queues.

\paragraph{org.gosa.command}

Führt ein Kommando aus wenn die eigene ID angebeben ist.


\paragraph{org.gosa.event}

Von Komponenten ausgelöste Events werden an dieser Stelle publiziert. Andere Komponenten
können sich für diese Nachrichten interessieren.

%command
%
% Die Kommando-Queue (Round Robin). Alle CommandRegistry-Objekte der GOsa-Server
% sind an dieser Stelle angedockt. Jeweils einem davon wird die Nachricht       
% privat zugestellt und es beantwortet sie nach der Ausführung des Kommandos.   
%
% Schreibberechtigung - sysop
% Leseberechtigung - gosa    


%goto.register
%
% Die GOto-Registrierungs Queue. Kann sich ein System nicht anmelden, muss es
% über einen sysop in der register queue mit dem System bekannt gemacht werden.
%
% Schreibberechtigung - sysop
% Leseberechtigung - none    
%
%
%goto.client
%
%
%goto.client.63262bcc-3ccf-11df-94a5-00016c9daa16
%goto.client.68f883ba-3ccf-11df-bd24-00016c9daa16
%
% Private r/w server/client Queue.
%
%software.debian
%software.redhat
%
% Repository handler

\section{Last und Latenz}

Ändert sich die Last eines Servers über einen gewissen Zeitraum und Delta, so wird diese
Lastinformation allen Systemen zur Verfügung gestellt.

Latenzmessungen laufen in einem einstellbaren Zeitinterval. Ein Server sendet allen anderen
Servern ein Latenzpaket, welches von diesen sofort beantwortet wird. Die verstrichene Zeit
wird in die Last/Latenzbewertung mit eingeht.

Kann der angesprochene Server die Anfrage selbst beantworten wird dies meist den
Zuschlag bekommen, da die Latenz hier am geringsten ist (0).

Entschieden wird nach der ResponseQuality:

$$ResponseIndex = ( Last * Lastgewichtung + Latenz * Latenzgewichtung ) * Systemgewichtung$$

{\it Last} in Prozent $->$ 0.10 = 10\%, {\it Latenz} in ms


\section{Capabilities}

Eine Capability besteht aus den folgenden Informationen:

\paragraph{Name}

Aufzurufender Funktionsname

\paragraph{Typ}

\begin{itemize}
\item[\bf Normal] ein Server wird gesucht, der mit dem geringsten ResponseIndex beantwortet die Anfrage
\item[\bf Combine] [TODO] alle Server die die Funktion bereitstellen werden befragt, das Ergebnis zusammengefügt
\item[\bf First result] alle Server die die Funktion bereitstellen werden befragt, der erste der sie ohne Fehler zurückliefert, liefert das Ergebnis. Die Abfragen werden damit eingestellt.
\end{itemize}


\section{Funktionsaufrufe}

Ein Client kann einen beliebigen GOsa-Server über HTTP-JSONRPC kontaktieren. Dieser führt die
Capability/ResponseIndex Bewertung durch und führt die Funktion entweder selbst aus oder
schickt die Anfrage auf den AMQP-Bus und leitet die Antwort an den aufrufenden Client
weiter.

Funktionsaufrufe werden vom ACL-Mapper gefiltert.


\section{Ablauf}

Die Initialisierung sorgt für:

\begin{itemize}
\item Laden der Konfiguration
\item Intialisiert die Informationsumgebung (env) die von allen Plugins zugreifbar ist
\item Fork und erzeugen der PID-Datei
\item Initialisiert die Plugins
\item Betritt die Hauptschleife (Scheduler, Timerinitialisierung)
\item Wird die Hauptschleife beendet, wird ein Shutdown/Join threads durchgeführt
\item Die PID wird entfernt
\end{itemize}


\paragraph{Env}

Diese Umgebung enthält die Konfiguration. Verwaltet Threads und deren Locks sowie
das GOsa-übergreifende Logging.


\paragraph{Plugins}

Jedes Plugin erhält die Gelegenheit sich zu Initialisieren. Hier bei kann es:

\begin{itemize}
\item Sich für AMQP-Queues registrieren (EventListener)
\item Threads starten die Plugin-Spezifische Dinge tun
\item Funktionen in der CommandRegistry zum Aufruf hinterlegen
\end{itemize}

Plugins können auf die interne API zurückgreifen, mit deren Hilfe Sie z.B.
auf Datenbankbackends zugreifen, Timer verwenden oder den Scheduler abfragen können.


\paragraph{CommandRegistry}

Die CommandRegistry führt übergebene (registrierte) Befehle mit Hilfe
des dazugehörigen Plugins aus. Wurde der Befehl ausgeführt, wird das
Ergebnis an den Aufrufer übermittelt.

Hier wird auch eine Bewertung der Jobs nach dem ResponseIndex und Capabilites durchgeführt.
Die Ausführung erfolgt entweder direkt über die CommandRegistry oder als verschickter
AMQP Job an einen bestimmten oder alle verfügbaren Server. Dies geschieht über die command Queue.


\paragraph{RPC2AMQP Proxy}

Kommt eine Anfrage beispielsweise über JSON-RPC herein, wird sie an die CommandRegistry
weitergeleitet.


\paragraph{Scheduler}

Der Scheduler wird über die command Queue mit
Jobs versorgt. Die direct-Queue weisst das Exec-Modul an den Befehl direkt
auszuführen, wohingegen bei command der Bewertungsmechanismus durchlaufen
wird.

Der Scheduler übernimmt einen Job, in dem das Wer, Was und Wann
festgehalten ist. Ist keine Ausführungszeit spezifiziert, wird der
Job nächstmöglich ausgeführt. Ist eine Ausführungszeit angegeben
wird für diesen Job ein Timer registriert, bei dessen Ablauf der
Job ausgeführt wird.

Jeder auszuführende Job erhält eine ID. Diese wird dem Aufrufer
instantan zurückgeliefert und gestattet ihm einen aktuellen Status
zu diesem Job abzufragen.

Die Jobs des Schedulers werden in einer Datenbank abgelegt und sind von
allen Servern über die Datenbank zugreifbar. Soll ein Takeover möglich
sein, so müssen alle Server die selbe Datenbank verwenden.

\paragraph{Job}

Who, What, When, Server, Result, Timer

